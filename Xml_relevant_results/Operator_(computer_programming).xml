<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>Wikipedia</sitename>
    <dbname>enwiki</dbname>
    <base>https://en.wikipedia.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.35.0-wmf.31</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">Wikipedia</namespace>
      <namespace key="5" case="first-letter">Wikipedia talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="100" case="first-letter">Portal</namespace>
      <namespace key="101" case="first-letter">Portal talk</namespace>
      <namespace key="108" case="first-letter">Book</namespace>
      <namespace key="109" case="first-letter">Book talk</namespace>
      <namespace key="118" case="first-letter">Draft</namespace>
      <namespace key="119" case="first-letter">Draft talk</namespace>
      <namespace key="446" case="first-letter">Education Program</namespace>
      <namespace key="447" case="first-letter">Education Program talk</namespace>
      <namespace key="710" case="first-letter">TimedText</namespace>
      <namespace key="711" case="first-letter">TimedText talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Operator (computer programming)</title>
    <ns>0</ns>
    <id>860030</id>
    <revision>
      <id>956139703</id>
      <parentid>955495815</parentid>
      <timestamp>2020-05-11T18:16:03Z</timestamp>
      <contributor>
        <username>DannyS712 bot</username>
        <id>35159807</id>
      </contributor>
      <minor/>
      <comment>Task 70: Update syntaxhighlight tags - remove use of deprecated &lt;source&gt; tags</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="22095" xml:space="preserve">{{short description|Construct used in computer programming is often associated to a mathematical operation}}
{{refimprove|date=January 2019}}

{{About|operators in computer programming|other uses|Operator (disambiguation)}}

[[Programming languages]] typically support a set of '''operators''': constructs which behave generally like functions, but which differ [[Syntax (programming languages)|syntactically]] or [[Semantics_(computer science)|semantically]] from usual functions. Common simple examples include arithmetic (addition with &lt;code&gt;+&lt;/code&gt;), comparison (with &lt;code&gt;&amp;gt;&lt;/code&gt;), and logical operations (such as &lt;code&gt;AND&lt;/code&gt; or &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;). More involved examples include [[Assignment (computer science)|assignment]] (usually &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;:=&lt;/code&gt;), [[Field (computer science)|field]] access in a record or object (usually &lt;code&gt;.&lt;/code&gt;), and the [[scope resolution operator]] (often &lt;code&gt;::&lt;/code&gt;). Languages usually define a set of built-in operators, and in some cases allow users to add new meanings to existing operators or even define completely new operators.

==Syntax==
[[Syntax (programming languages)|Syntactically]] operators usually contrast to [[Function (computer science)|functions]]. In most languages, functions may be seen as a special form of prefix operator with fixed [[Order of operations|precedence]] level and associativity, often with compulsory [[Bracket#Parentheses .28 .29|parentheses]] e.g. &lt;code&gt;Func(a)&lt;/code&gt; (or &lt;code&gt;(Func a)&lt;/code&gt; in [[Lisp (programming language)|Lisp]]). Most languages support programmer-defined functions, but cannot really claim to support programmer-defined operators, unless they have more than prefix notation and more than a single precedence level. Semantically operators can be seen as special form of function with different calling notation and a limited number of parameters (usually 1 or 2).

The position of the operator with respect to its operands may be [[Polish notation|prefix]], [[infix notation|infix]] or [[postfix notation|postfix]], and the syntax of an [[expression (computer science)|expression]] involving an operator depends on its [[arity]] (number of [[operand]]s), precedence, and (if applicable), [[Operator associativity|associativity]]. Most programming languages support [[binary operation|binary operators]] and a few [[unary operation|unary operators]], with a few supporting more operands, such as the [[?:]] operator in C, which is ternary. There are prefix unary operators, such as unary minus &lt;code&gt;-x&lt;/code&gt;, and postfix unary operators, such as [[post-increment]] &lt;code&gt;x++&lt;/code&gt;; and binary operations are infix, such as &lt;code&gt;x + y&lt;/code&gt; or &lt;code&gt;x = y&lt;/code&gt;. Infix operations of higher arity require additional symbols, such as the [[ternary operator]] ?: in C, written as &lt;code&gt;a ? b : c&lt;/code&gt; – indeed, this is the only common example, it is often referred to as ''the'' ternary operator. Prefix and postfix operations can support any desired arity, however, such as &lt;code&gt;1 2 3 4 +&lt;/code&gt;.

Occasionally&lt;ref&gt;{{Cite web|url=https://reference.wolfram.com/language/tutorial/OperatorInputForms.html.en|title=Operator Input Forms—Wolfram Language Documentation|website=reference.wolfram.com}}&lt;/ref&gt;&lt;ref&gt;{{Cite web|url=http://maxima.sourceforge.net/docs/manual/maxima_7.html|title=Maxima 5.42.0 Manual: 7. Operators|website=maxima.sourceforge.net}}&lt;/ref&gt; parts of a language may be described as "matchfix" or "circumfix"&lt;ref&gt;{{Cite web|url=https://mythryl.org/my-Prefix__Postfix_and_Circumfix_Operators.html|title=Prefix, Postfix and Circumfix Operators|website=mythryl.org}}&lt;/ref&gt;&lt;ref&gt;{{Cite web|url=http://doc.perl6.org/language/operators#___top|title=Operators|website=doc.perl6.org}}&lt;/ref&gt; operators, either to simplify the language's description or implementation. A circumfix operator consists of two or more parts which enclose its operands. Circumfix operators have the highest precedence, with their contents being evaluated and the resulting value used in the surrounding expression. The most familiar circumfix operator are the parentheses mentioned above, used to indicate which parts of an expression are to be evaluated before others. Another example from physics is the [[Inner product space|inner product]] notation of Dirac's [[bra–ket notation]]. Circumfix operators are especially useful to denote operations that involve many or varying numbers of operands.

The specification of a language will specify the syntax the operators it supports, while languages such as [[Prolog]] that support programmer-defined operators require that the syntax be defined by the programmer.

==Semantics==
The semantics of operators particularly depends on value, evaluation strategy, and argument passing mode (such as boolean short-circuiting). Simply, an [[Expression (computer science)|expression]] involving an operator is evaluated in some way, and the resulting [[Value (computer science)|value]] may be just a value (an r-value), or may be an object allowing assignment (an l-value).

In simple cases this is identical to usual function calls; for example, addition &lt;code&gt;x + y&lt;/code&gt; is generally equivalent to a function call &lt;code&gt;add(x, y)&lt;/code&gt; and less-than comparison &lt;code&gt;x &amp;lt; y&lt;/code&gt; to &lt;code&gt;lt(x, y)&lt;/code&gt;, meaning that the arguments are evaluated in their usual way, then some function is evaluated and the result is returned as a value. However, the semantics can be significantly different. For example, in assignment &lt;code&gt;a = b&lt;/code&gt; the target &lt;code&gt;a&lt;/code&gt; is not evaluated, but instead its ''location'' (address) is used to store the value of &lt;code&gt;b&lt;/code&gt; – corresponding to [[call-by-reference]] semantics. Further, an assignment may be a statement (no value), or may be an expression (value), with the value itself either an r-value (just a value) or an l-value (able to be assigned to). As another example, the [[scope resolution operator]] :: and the element access operator . (as in &lt;code&gt;Foo::Bar&lt;/code&gt; or &lt;code&gt;a.b&lt;/code&gt;) operate not on values, but on ''names'', essentially [[call-by-name]] semantics, and their value is a name.

Use of l-values as operator operands is particularly notable in unary [[increment and decrement operators]]. In C, for instance, the following statement is legal and well-defined, and depends on the fact that array indexing returns an l-value:
&lt;syntaxhighlight lang=c&gt;
x = ++a[i];
&lt;/syntaxhighlight&gt;

An important use is when a left-associative binary operator modifies its left argument (or produces a side effect) and then evaluates to that argument as an l-value.{{efn|Conversely a right-associative operator with its right argument, though this is rarer.}} This allows a sequence of operators all affecting the original argument, allowing a [[fluent interface]], similar to [[method cascading]]. A common example is the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator in the C++ &lt;code&gt;[[iostream]]&lt;/code&gt; library, which allows fluent output, as follows:
&lt;syntaxhighlight lang=cpp&gt;
cout &lt;&lt; "Hello" &lt;&lt; " " &lt;&lt; "world!" &lt;&lt; endl;
&lt;/syntaxhighlight&gt;

==User-defined operators==
A language may contain a fixed number of built-in operators (e.g. {{mono|1=+, -, *, &amp;lt;, &amp;lt;=, !, =}}, etc. in [[Operators in C and C++|C and C++]], [[PHP]]), or it may allow the creation of programmer-defined operators (e.g. [[Prolog]]&lt;ref&gt;{{Cite web|url=https://www.swi-prolog.org/pldoc/man?predicate=op/3|title=SWI-Prolog -- op/3|website=www.swi-prolog.org}}&lt;/ref&gt;, [[Seed7]]&lt;ref&gt;{{Cite web|url=http://seed7.sourceforge.net/examples/operator.htm|title=Declare an operator|website=seed7.sourceforge.net}}&lt;/ref&gt;, [[F Sharp (programming language)|F#]], [[OCaml]], [[Haskell programming language|Haskell]]). Some programming languages restrict operator symbols to special characters like {{mono|1='''[[Addition|+]]'''}} or {{mono|1='''[[Assignment (computer science)|:=]]'''}} while others allow also names like &lt;code&gt;[[Integer_division#Division_of_integers|'''div''']]&lt;/code&gt; (e.g. [[Pascal (programming language)|Pascal]]).

Most languages have a built-in set of operators, but do not allow user-defined operators, as this significantly complicates parsing.{{efn|Introducing a new operator changes the [[lexical specification]] of the language, which changes the [[lexical analysis]]. The arity and precedence of the operator is then part of the phrase syntax of the language, which changes the phrase-level analysis. For example, adding an operator &lt;code&gt;@&lt;/code&gt; requires lexing and tokenizing this character, and the phrase structure (syntax tree) depends on the arity and precedence of this operator.}} Many languages only allow operators to be used for built-in types, but others allow existing operators to be used for user-defined types; this is known as [[operator overloading]]. Some languages allow new operators to be defined, however, either at compile time or at run time. This may involve meta-programming (specifying the operators in a separate language), or within the language itself. Definition of new operators, particularly runtime definition, often makes correct [[static analysis]] of programs impossible, since the syntax of the language may be Turing-complete, so even constructing the syntax tree may require solving the halting problem, which is impossible. This occurs for [[Perl]], for example, and some dialects of [[Lisp (programming language)|Lisp]].

==Examples==
{{category see also|Operators (programming)}}
Common examples that differ syntactically are mathematical [[arithmetic operation]]s, e.g. "&amp;gt;" for "[[inequality (mathematics)|greater than]]", with names often outside the language's set of [[identifier (computer science)|identifiers]] for functions, and called with a syntax different from the language's syntax for calling functions. As a function, "greater than" would generally be named by an identifier, such as &lt;code&gt;gt&lt;/code&gt; or &lt;code&gt;greater_than&lt;/code&gt; and called as a function, as &lt;code&gt;gt(x, y)&lt;/code&gt;. Instead, the operation uses the special character &lt;code&gt;&amp;gt;&lt;/code&gt; (which is tokenized separately during [[lexical analysis]]), and infix notation, as &lt;code&gt;x &amp;gt; y&lt;/code&gt;.

Common examples that differ semantically (by argument passing mode) are boolean operations, which frequently feature [[short-circuit evaluation]]: e.g. a short-circuiting conjunction (X AND Y) that only evaluates later arguments if earlier ones are not false, in a language with strict call-by-value functions. This behaves instead similarly to if/then/else.

Less common operators include:
* [[Comma operator]]: &lt;code&gt;e, f&lt;/code&gt;
* [[Dereference operator]]: &lt;code&gt;*p&lt;/code&gt; and address-of operator: &lt;code&gt;&amp;amp;x&lt;/code&gt;
* [[?:]] or ternary operator: &lt;code&gt;number = spell_out_numbers ? "forty-two" : 42&lt;/code&gt;
** [[Elvis operator]]: &lt;code&gt;x ?: y&lt;/code&gt;
* [[Null coalescing operator]]: &lt;code&gt;x ?? y&lt;/code&gt;
* [[Spaceship operator]] (for [[three-way comparison]]): &lt;code&gt;x &amp;lt;=&amp;gt; y&lt;/code&gt;

==Compilation==
A compiler can implement operators and functions with [[Subroutine|subroutine calls]] or with [[Inline expansion|inline code]]. Some built-in operators supported by a language have a direct mapping to a small number of [[Machine code|instructions]] commonly found on [[central processing units]], though others (''e.g.'' '+' used to express [[string concatenation]]) may have complicated implementations.

== Operator overloading ==
{{main|Operator overloading}}

In some programming languages an operator may be ''ad-hoc polymorphic'', that is, have definitions for more than one kind of data, (such as in [[Java (programming language)|Java]] where the &lt;tt&gt;+&lt;/tt&gt; operator is used both for the addition of numbers and for the concatenation of strings). Such an operator is said to be ''overloaded''. In languages that support operator overloading by the programmer (such as [[C++]]) but have a limited set of operators, operator overloading is often used to define customized uses for operators.

In the example &lt;code&gt;IF ORDER_DATE &gt; "12/31/2011" AND ORDER_DATE &lt; "01/01/2013" THEN CONTINUE ELSE STOP&lt;/code&gt;, the operators are: "&gt;" (greater than), "AND" and "&lt;" (less than).

== Operand coercion ==
{{further|Type conversion}}
Some languages also allow for the operands of an operator to be implicitly converted, or ''[[Type conversion#Implicit type conversion|coerced]]'', to suitable data types for the operation to occur. For example, in [[Perl]] coercion rules lead into &lt;code&gt;12 + "3.14"&lt;/code&gt; producing the result of &lt;code&gt;15.14&lt;/code&gt;. The text &lt;code&gt;"3.14"&lt;/code&gt; is converted to the number 3.14 before addition can take place. Further, &lt;code&gt;12&lt;/code&gt; is an integer and &lt;code&gt;3.14&lt;/code&gt; is either a floating or fixed-point number (a number that has a decimal place in it) so the integer is then converted to a floating point or fixed-point number respectively.

[[JavaScript]] follows opposite rules—finding the same expression above, it will convert the integer &lt;code&gt;12&lt;/code&gt; into a string &lt;code&gt;"12"&lt;/code&gt;, then concatenate the two operands to form &lt;code&gt;"123.14"&lt;/code&gt;.

In the presence of coercions in a language, the programmer must be aware of the specific rules regarding operand types and the operation result type to avoid subtle programming mistakes.

== Operator features in programming languages ==
The following table shows the operator features in several programming languages:

{| class="sortable wikitable"
|-
!Programming language
!Nonalphanumeric operator symbols
!Alphanumeric operator symbols
!Prefix
!Infix
!Postfix
!Precedence
!Associativity
!Overloading
!Programmer-defined overloading
!Programmer-defined operator symbols
|-
| [[ALGOL 68]]
| {{mono|1=+* ** * / % %* %× - + &amp;lt; &amp;lt;= &gt;= &gt; = /= &amp; -:= +:= *:= /:= %:= %*:= +=: :=: :/=:}}
(All operators have '''bold''' Alphanumeric equivalents, c.f. next column.  Some have non [[ASCII]] equivalents, c.f. below.)
{{mono|1=¬ +× ⊥ ↑ ↓ ⌊ ⌈ × ÷ ÷× ÷* □ ≤ ≥ ≠ ∧ ∨ ×:= ÷:= ÷×:= ÷*:= %×:= :≠:}}
| {{mono|'''not''' '''abs''' '''arg''' '''bin''' '''entier''' '''leng''' '''level''' '''odd''' '''repr''' '''round''' '''shorten''' '''i''' '''shl''' '''shr''' '''up''' '''down''' '''lwb''' '''upb''' '''lt''' '''le''' '''ge''' '''gt''' '''eq''' '''ne''' '''and''' '''or''' '''over''' '''mod''' '''elem''' '''minusab''' '''plusab''' '''timesab''' '''divab''' '''overab''' '''modab''' '''plusto''' '''is''' '''{{Not a typo|isnt}}'''}}
| {{Yes}}
| {{Yes}}
| {{No}}
| {{Yes}} &lt;small&gt;(prefix operators always have priority 10)&lt;/small&gt;
| Infix operators are left associative, prefix operators are right associative
| {{Yes}}
| {{Yes}}
| {{Yes}}
|-
| [[APL (programming language)|APL]]
| {{mono|1=+ - × ÷ ⌈ ⌊ * ⍟ &amp;#124; ! ○ ~ ∨ ∧ ⍱ ⍲ &amp;lt; ≤ = ≥ &gt; ≠ . @ ≡ ≢ ⍴ , ⍪ ⍳ ↑ ↓ ? ⍒ ⍋ ⍉ ⌽ ⊖ ∊ ⊥ ⊤ ⍎ ⍕ ⌹ ⊂ ⊃ ∪ ∩ ⍷ ⌷ ∘ → ← / ⌿ \ ⍀ ¨ ⍣ &amp; ⍨ ⌶ ⊆ ⊣ ⊢ ⍠ ⍤ ⌸ ⌺ ⍸}}
| bgcolor="yellow" | Alphanumeric symbols need a ⎕ before the keyword
| {{Yes}} &lt;small&gt;(first-order functions only)&lt;/small&gt;
| {{Yes}} 
| {{Yes}} &lt;small&gt;(higher-order functions only)&lt;/small&gt;
| Higher-order functions precede first-order functions
| Higher-order functions are left associative, first-order functions are right associative
| {{Yes}}
| {{Yes}}
| {{Yes}} &lt;small&gt;(alphanumeric only)&lt;/small&gt;
|-
| [[C (programming language)|C]]
| rowspan="2" | {{mono|1=() [] -&gt; . ! ~ ++ -- + - * &amp; / % &lt;&lt; &gt;&gt; &lt; &lt;= &gt; &gt;= == != ^ &lt;nowiki&gt;|&lt;/nowiki&gt; &amp;&amp; &lt;nowiki&gt;||&lt;/nowiki&gt; [[?:]] = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;=}}
| {{mono|1=[[sizeof]]}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{No}}
| {{No}}
|-
| [[C++]] ([[Operators in C and C++|more]])
| {{mono|1=[[sizeof]] [[typeid]] [[new (C++)|new]] [[delete (C++)|delete]] [[Exception handling|throw]] [[decltype]] [[static_cast]] [[dynamic cast]] [[reinterpret_cast]] [[const_cast]]}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{No}}
|-
| [[C sharp (programming language)|C#]] ([[C Sharp syntax#Operators|more]])
| Same as C/C++, along with {{mono|[[?.]] ?[] [[Null coalescing operator|??]]}}
| {{mono|1=[[sizeof]] nameof new stackalloc await [[Exception handling|throw]] checked unchecked is as delegate default true false}} &lt;br /&gt; '''[[Language Integrated Query|LINQ]]:''' {{mono|1=from select where group...by group...by...into join...in...on...equals join...in...on...equals...into orderby orderby...descending}} &lt;br /&gt; '''[[Roslyn (compiler)|Roslyn]]-only:''' {{mono|1=__makeref __refvalue __reftype}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{No}}
|-
| [[Java (programming language)|Java]]
| Same as C/C++
| [[Java syntax#Instantiation|new]] [[Exception handling|throw]] [[instanceof]]
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{No}}
| {{No}}
|-
| [[Eiffel (programming language)|Eiffel]]
| {{mono|1=[] + - * / // = /= }}
| {{mono|1=not and or implies "and then" "or else" }}
| {{Yes}}
| {{Yes}}
| {{No}}
| {{Yes}}
| {{Yes}}
| {{No}}
| {{Yes}}
| {{Yes}}
|-
| [[Haskell (programming language)|Haskell]]
| {{mono|1=+ - * / ^ ^^ ** == /= &gt; &lt; &gt;= &lt;= &amp;&amp; &amp;#x7c;&amp;#x7c; &gt;&gt;= &gt;&gt; $ $! . ++ !! :}} &lt;small&gt;Many more in common libraries&lt;/small&gt;
| bgcolor="yellow" | The function's name must be put into backticks
| {{Yes}}
| {{Yes}}
| {{No}}
| {{Yes}}
| {{Yes}}
| colspan="2" {{Yes}}, using [[Type class]]es
| {{Yes}}
|-
| [[Pascal (programming language)|Pascal]]
| {{mono|1=* / + - = &lt; &gt; &lt;&gt; &lt;= &gt;= :=}}
| [[Negation#Programming|not]] [[Integer division#Division of integers|div]] [[Modulo operation|mod]] [[Logical conjunction|and]] [[Logical disjunction|or]] in
| {{Yes}}
| {{Yes}}
| {{No}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{No}}
| {{No}}
|-
| [[Perl]]
| {{mono|1=-&gt; ++ -- ** ! ~ \ + - . =~ !~ * / % &lt; &gt; &lt;= &gt;= == != &lt;=&gt; ~~ &amp; &amp;#124;  ^ &amp;amp;&amp;amp; &amp;#124;&amp;#124; ' ''{{Not a typo|  // .. ... ?: = += -= *= , =&gt;}} }}
| {{mono|1=print sort chmod chdir rand and or not xor lt gt le ge eq ne cmp x }}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{No}}
|-
| [[Raku (programming language)|Raku]]
| {{mono|1=++ -- ** ! ~ ~~ * / + - . &lt; &gt; &lt;= &gt;= == != &lt;=&gt; &amp; &amp;#124; ^ &amp;amp;&amp;amp; &amp;#124;&amp;#124; //}} &lt;ref&gt;{{Cite web|url=https://docs.perl6.org/language/operators|title=Operators|website=docs.perl6.org}}&lt;/ref&gt;
| {{mono|1=print sort chmod chdir rand and or not xor lt gt le ge eq ne leg cmp x xx}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}&lt;ref&gt;{{Cite web|url=https://docs.perl6.org/language/functions#Defining_Operators|title=Functions|website=docs.perl6.org}}&lt;/ref&gt;
|-
| [[PHP]]
| {{mono|1=[] ** ++ -- ~  @!&lt;ref&gt;{{Cite web|url=https://php.net/manual/en/language.operators.errorcontrol.php|title=PHP: Error Control Operators - Manual|website=php.net}}&lt;/ref&gt; * / % + - . &lt;&lt; &gt;&gt; &lt; &lt;= &gt; &gt;= == != === !== &lt;&gt; [[Spaceship operator|&lt;=&gt;]] &amp; ^ &lt;nowiki&gt;|&lt;/nowiki&gt; &amp;&amp; &lt;nowiki&gt;||&lt;/nowiki&gt; [[Null coalescing operator|??]] [[?:]] = += -= *= **= /= .= %= &amp;= &lt;nowiki&gt;|=&lt;/nowiki&gt; ^= &lt;&lt;= &gt;&gt;= }}
| {{mono|1=clone new unset print echo isset [[instanceof]] [[Logical conjunction|and]] [[Logical disjunction|or]] [[Exclusive or|xor]]}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{No}}
| {{No}}
| {{No}}
|-
| [[PL/I]]
| {{mono|1=( ) -&gt; + - * / ** &gt; &amp;not;&gt; &gt;= = &amp;not;= &lt;= &lt; &amp;not;&lt; &amp;not; &lt;nowiki&gt;&amp;&lt;/nowiki&gt; &lt;nowiki&gt;|&lt;/nowiki&gt; &lt;nowiki&gt;||&lt;/nowiki&gt;}}
|  
| {{Yes}}
| {{Yes}}
| {{No}}
| {{Yes}}
| {{Yes}}
| {{No}}
| {{No}}
| {{No}}
|-
| [[Prolog]]
| {{mono|1=:- ?- ; , . =.. = \= &lt; =&lt; &gt;= &gt; == \== - + / *}}
| {{mono|1=spy nospy not is mod}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{No}}
| {{No}}
| {{Yes}}
|-
| [[Seed7]]
| {{mono|1={} [] -&gt; ** ! + - * / &lt;&lt; &gt;&gt; &amp; &gt;&lt; &lt;nowiki&gt;|&lt;/nowiki&gt; = &lt;&gt; &gt; &gt;= &lt; &lt;= &lt;&amp; := +:= -:= *:= /:= &lt;&lt;:= &gt;&gt;:= &amp;:= @:=}}
| {{mono|1=conv varConv parse [[Complex conjugate|conj]] [[Integer division#Division of integers|div]] [[Remainder|rem]] [[Modulo operation|mdiv mod]] times mult in [[Negation#Programming|not]] [[Logical conjunction|and]] [[Logical disjunction|or]] digits lpad rpad lpad0}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
|-
| [[Smalltalk]]
| (yes - Up to two characters&lt;ref name="BinaryMessages"&gt;{{cite web|first=Adele|last=Goldberg|url=http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf|title=Smalltalk-80: The Language and its Implementation, p. 27, ISBN 0-201-11371-6}}&lt;/ref&gt;)
| bgcolor="yellow" | Alphanumeric symbols need a colon after the keyword
| {{No}}
| {{Yes}}
| {{Yes}}
| {{No}}
| {{No}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
|-
| [[Swift (programming language)|Swift]]
| Any Unicode symbol string except {{mono|1=.}}, including {{mono|1=! ~ + - * / % =+ =- =* =/ =% &amp;+ &amp;- &amp;* =&amp;+ =&amp;- =&amp;* &amp;&amp; &lt;nowiki&gt;||&lt;/nowiki&gt; &lt;&lt; &gt;&gt; &amp; &lt;nowiki&gt;|&lt;/nowiki&gt; ^ == != &lt; &lt;= &gt; &gt;= ?? ... ..&lt;}} in standard library
| {{mono|1=is as as?}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}} &lt;small&gt;(defined as partial order in precedence groups)&lt;/small&gt;
| {{Yes}} &lt;small&gt;(defined as part of precedence groups)&lt;/small&gt;
| {{Yes}}
| {{Yes}}
| {{Yes}}
|-
| [[Visual Basic .NET]]
| rowspan="2" | {{mono|1=() . ! ?() ?. ?! + - * / \ &amp; &lt;&lt; &gt;&gt; &lt; &lt;= &gt; &gt;= ^ &lt;&gt; = += -= *= /= \= &amp;= ^= &lt;&lt;= &gt;&gt;=}}
| {{mono|1=New Await Mod Like Is IsNot Not And AndAlso Or OrElse Xor If(...,...) If(...,...,...) GetXmlNamespace(...) GetType(...) NameOf(...) TypeOf...Is TypeOf...IsNot DirectCast(...,...) TryCast(...,...) CType(...,...) CBool(...) CByte(...) CChar(...) CDate(...) CDec(...) CDbl(...) CInt(...) CLng(...) CObj(...) CSByte(...) CShort(...) CSng(...) CStr(...) CUInt(...) CULng(...) CUShort(...)}} &lt;br /&gt; '''[[Language Integrated Query|LINQ]]:''' {{mono|1=From Aggregate...Into Select Distinct Where {{nowrap|&lt;Order By&gt;...[Ascending{{pipe}}Descending]}} Take {{nowrap|&lt;Take While&gt;}} Skip {{nowrap|&lt;Skip While&gt;}} Let Group...By...Into Join...On &lt;Group Join...On...Into&gt;}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{Yes}}
| {{No}}
|-
|}

==See also==
*[[Relational operator]]

==Notes==
{{notelist}}

==References==
{{reflist}}

==External links==
*{{Commonscatinline|Operators (programming)}}

[[Category:Operators (programming)| ]]
[[Category:Programming constructs]]</text>
      <sha1>qz1qizosltepglnvgbmuatdk1aynmy3</sha1>
    </revision>
  </page>
</mediawiki>
