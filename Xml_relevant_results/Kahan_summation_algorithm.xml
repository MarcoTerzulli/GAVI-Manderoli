<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>Wikipedia</sitename>
    <dbname>enwiki</dbname>
    <base>https://en.wikipedia.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.35.0-wmf.31</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">Wikipedia</namespace>
      <namespace key="5" case="first-letter">Wikipedia talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="100" case="first-letter">Portal</namespace>
      <namespace key="101" case="first-letter">Portal talk</namespace>
      <namespace key="108" case="first-letter">Book</namespace>
      <namespace key="109" case="first-letter">Book talk</namespace>
      <namespace key="118" case="first-letter">Draft</namespace>
      <namespace key="119" case="first-letter">Draft talk</namespace>
      <namespace key="446" case="first-letter">Education Program</namespace>
      <namespace key="447" case="first-letter">Education Program talk</namespace>
      <namespace key="710" case="first-letter">TimedText</namespace>
      <namespace key="711" case="first-letter">TimedText talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Kahan summation algorithm</title>
    <ns>0</ns>
    <id>373216</id>
    <revision>
      <id>953520975</id>
      <parentid>943632761</parentid>
      <timestamp>2020-04-27T16:42:00Z</timestamp>
      <contributor>
        <ip>95.88.202.215</ip>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="23201" xml:space="preserve">In [[numerical analysis]], the '''Kahan summation algorithm''', also known as '''compensated summation''',&lt;ref&gt;Strictly, there exist other variants of compensated summation as well: see {{cite book |first=Nicholas |last=Higham |title=Accuracy and Stability of Numerical Algorithms (2 ed) |publisher=SIAM |year=2002 |pages=110–123 |isbn=978-0-89871-521-7}}&lt;/ref&gt; significantly reduces the [[numerical error]] in the total obtained by adding a [[sequence]] of finite-[[decimal precision|precision]] [[floating-point number]]s, compared to the obvious approach. This is done by keeping a separate ''running compensation'' (a variable to accumulate small errors).

In particular, simply summing ''n'' numbers in sequence has a worst-case error that grows proportional to ''n'', and a [[root mean square]] error that grows as &lt;math&gt;\sqrt{n}&lt;/math&gt; for random inputs (the roundoff errors form a [[random walk]]).&lt;ref name=Higham93&gt;{{Citation | title=The accuracy of floating point summation | first1=Nicholas J. | last1=Higham | journal=[[SIAM Journal on Scientific Computing]] | volume=14 | issue=4 | pages=783–799 | doi=10.1137/0914050 | year=1993 | citeseerx=10.1.1.43.3535 | url=https://pdfs.semanticscholar.org/5c17/9d447a27c40a54b2bf8b1b2d6819e63c1a69.pdf}}.&lt;/ref&gt;  With compensated summation, the worst-case error bound is effectively independent of ''n'', so a large number of values can be summed with an error that only depends on the floating-point [[precision (arithmetic)|precision]].&lt;ref name=Higham93/&gt;

The [[algorithm]] is attributed to [[William Kahan]].&lt;ref name="kahan65"&gt;{{Citation |last=Kahan |first=William |title=Further remarks on reducing truncation errors |date=January 1965 |url=http://mgnet.org/~douglas/Classes/na-sc/notes/kahan.pdf |journal=[[Communications of the ACM]] |volume=8 |issue=1 |page=40 |archive-url=https://web.archive.org/web/20180209003010/http://mgnet.org/~douglas/Classes/na-sc/notes/kahan.pdf |doi=10.1145/363707.363723 |archive-date=9 February 2018}}.&lt;/ref&gt; Similar, earlier techniques are, for example, [[Bresenham's line algorithm]], keeping track of the accumulated error in integer operations (although first documented around the same time&lt;ref&gt;{{cite journal |first=Jack E. |last=Bresenham |url=http://www.research.ibm.com/journal/sj/041/ibmsjIVRIC.pdf |title=Algorithm for computer control of a digital plotter |journal=IBM Systems Journal |volume=4 |issue=1 |date=January 1965 |pages=25–30 |doi=10.1147/sj.41.0025 }}&lt;/ref&gt;) and the [[delta-sigma modulation]]&lt;ref&gt;{{cite journal |first1=H. |last1=Inose |first2=Y. |last2=Yasuda |first3=J. |last3=Murakami |title=A Telemetering System by Code Manipulation – ΔΣ Modulation |journal=IRE Transactions on Space Electronics and Telemetry |date=September 1962 |pages=204–209|doi=10.1109/IRET-SET.1962.5008839 }}&lt;/ref&gt; (integrating, not just summing the error).

==The algorithm==
In [[pseudocode]], the algorithm is:

 '''function''' KahanSum(input)
     '''var''' sum = 0.0                    // Prepare the accumulator.
     '''var''' c = 0.0                      // A running compensation for lost low-order bits.
     '''for''' i = 1 '''to''' input.length '''do'''     // The array ''input'' has elements indexed input[1] to input[input.length].
         '''var''' y = input[i] - c         // ''c'' is zero the first time around.
         '''var''' t = sum + y              // Alas, ''sum'' is big, ''y'' small, so low-order digits of ''y'' are lost.
         c = (t - sum) - y            // ''(t - sum)'' cancels the high-order part of ''y''; subtracting ''y'' recovers negative (low part of ''y'')
         sum = t                      // Algebraically, ''c'' should always be zero. Beware overly-aggressive optimizing compilers!
     '''next''' i                           // Next time around, the lost low part will be added to ''y'' in a fresh attempt.
     '''return''' sum

===Worked example===
This example will be given in decimal. Computers typically use binary arithmetic, but the principle being illustrated is the same. Suppose we are using six-digit decimal floating-point arithmetic, &lt;code&gt;sum&lt;/code&gt; has attained the value 10000.0, and the next two values of &lt;code&gt;input[i]&lt;/code&gt; are 3.14159 and 2.71828. The exact result is 10005.85987, which rounds to 10005.9. With a plain summation, each incoming value would be aligned with &lt;code&gt;sum&lt;/code&gt;, and many low-order digits would be lost (by truncation or rounding). The first result, after rounding, would be 10003.1. The second result would be 10005.81828 before rounding and 10005.8 after rounding. This is not correct.

However, with compensated summation, we get the correct rounded result of 10005.9.

Assume that &lt;code&gt;c&lt;/code&gt; has the initial value zero.
   y = 3.14159 - 0.00000             ''y = input[i] - c''
   t = 10000.0 + 3.14159
     = 10003.14159                   But only six digits are retained.
     = 10003.1                       Many digits have been lost!
   c = (10003.1 - 10000.0) - 3.14159 This '''must''' be evaluated as written! 
     = 3.10000 - 3.14159             The assimilated part of ''y'' recovered, vs. the original full ''y''.
     = -0.0415900                    Trailing zeros shown because this is six-digit arithmetic.
 sum = 10003.1                       Thus, few digits from ''input(i'') met those of ''sum''.

The sum is so large that only the high-order digits of the input numbers are being accumulated. But on the next step, &lt;code&gt;c&lt;/code&gt; gives the error.
   y = 2.71828 - (-0.0415900)        The shortfall from the previous stage gets included.
     = 2.75987                       It is of a size similar to ''y'': most digits meet.
   t = 10003.1 + 2.75987             But few meet the digits of ''sum''.
     = 10005.85987                   And the result is rounded
     = 10005.9                       To six digits.
   c = (10005.9 - 10003.1) - 2.75987 This extracts whatever went in.
     = 2.80000 - 2.75987             In this case, too much.
     = 0.040130                      But no matter, the excess would be subtracted off next time.
 sum = 10005.9                       Exact result is 10005.85987, this is correctly rounded to 6 digits.

So the summation is performed with two accumulators: &lt;code&gt;sum&lt;/code&gt; holds the sum, and &lt;code&gt;c&lt;/code&gt; accumulates the parts not assimilated into &lt;code&gt;sum&lt;/code&gt;, to nudge the low-order part of &lt;code&gt;sum&lt;/code&gt; the next time around. Thus the summation proceeds with "guard digits" in &lt;code&gt;c&lt;/code&gt;, which is better than not having any, but is not as good as performing the calculations with double the precision of the input. However, simply increasing the precision of the calculations is not practical in general; if &lt;code&gt;input&lt;/code&gt; is already in double precision, few systems supply [[quadruple precision]], and if they did, &lt;code&gt;input&lt;/code&gt; could then be in quadruple precision.

==Accuracy==
A careful analysis of the errors in compensated summation is needed to appreciate its accuracy characteristics.  While it is more accurate than naive summation, it can still give large relative errors for ill-conditioned sums.

Suppose that one is summing ''n'' values ''x''&lt;sub&gt;''i''&lt;/sub&gt;, for {{nobr|''i'' {{=}} 1, ... ,''n''}}.  The exact sum is
: &lt;math&gt;S_n = \sum_{i=1}^n x_i&lt;/math&gt; (computed with infinite precision).
With compensated summation, one instead obtains &lt;math&gt;S_n + E_n&lt;/math&gt;, where the error &lt;math&gt;E_n&lt;/math&gt; is bounded by&lt;ref name=Higham93/&gt;
: &lt;math&gt;|E_n| \le \big[2\varepsilon + O(n\varepsilon^2)\big] \sum_{i=1}^n |x_i|,&lt;/math&gt;
where ''ε'' is the [[machine precision]] of the arithmetic being employed (e.g. ''ε''&amp;nbsp;≈&amp;nbsp;10&lt;sup&gt;−16&lt;/sup&gt; for IEEE standard [[double-precision]] floating point).  Usually, the quantity of interest is the [[relative error]] &lt;math&gt;|E_n|/|S_n|&lt;/math&gt;, which is therefore bounded above by
: &lt;math&gt;\frac{|E_n|}{|S_n|} \le \big[2\varepsilon + O(n\varepsilon^2)\big] \frac{\sum\limits_{i=1}^n |x_i|}{\left|\sum\limits_{i=1}^n x_i\right|}.&lt;/math&gt;

In the expression for the relative error bound, the fraction Σ|''x&lt;sub&gt;i&lt;/sub&gt;''|/|Σ''x&lt;sub&gt;i&lt;/sub&gt;''| is the [[condition number]] of the summation problem.  Essentially, the condition number represents the ''intrinsic'' sensitivity of the summation problem to errors, regardless of how it is computed.&lt;ref&gt;{{cite book |first1=Lloyd N. |authorlink1=Lloyd N. Trefethen |last1=Trefethen |first2=David |last2=Bau |title=Numerical Linear Algebra |publisher=SIAM |location=Philadelphia |year=1997 |isbn=978-0-89871-361-9}}&lt;/ref&gt;  The relative error bound of ''every'' ([[backwards stable]]) summation method by a fixed algorithm in fixed precision (i.e. not those that use [[arbitrary-precision]] arithmetic, nor algorithms whose memory and time requirements change based on the data), is proportional to this condition number.&lt;ref name=Higham93/&gt;  An ''ill-conditioned'' summation problem is one in which this ratio is large, and in this case even compensated summation can have a large relative error.  For example, if the summands ''x&lt;sub&gt;i&lt;/sub&gt;'' are uncorrelated random numbers with zero mean, the sum is a [[random walk]], and the condition number will grow proportional to &lt;math&gt;\sqrt{n}&lt;/math&gt;.  On the other hand, for random inputs with nonzero mean the condition number asymptotes to a finite constant as &lt;math&gt;n \to \infty&lt;/math&gt;.  If the inputs are all [[non-negative]], then the condition number is 1.

Given a condition number, the relative error of compensated summation is effectively independent of ''n''.  In principle, there is the O(''nε''&lt;sup&gt;2&lt;/sup&gt;) that grows linearly with ''n'', but in practice this term is effectively zero: since the final result is rounded to a precision ''ε'', the ''nε''&lt;sup&gt;2&lt;/sup&gt; term rounds to zero, unless ''n'' is roughly 1/''ε'' or larger.&lt;ref name=Higham93/&gt;  In double precision, this corresponds to an ''n'' of roughly 10&lt;sup&gt;16&lt;/sup&gt;, much larger than most sums.  So, for a fixed condition number, the errors of compensated summation are effectively ''O''(''ε''), independent of&amp;nbsp;''n''.

In comparison, the relative error bound for naive summation (simply adding the numbers in sequence, rounding at each step) grows as &lt;math&gt;O(\varepsilon n)&lt;/math&gt; multiplied by the condition number.&lt;ref name=Higham93/&gt;  This worst-case error is rarely observed in practice, however, because it only occurs if the rounding errors are all in the same direction. In practice, it is much more likely that the rounding errors have a random sign, with zero mean, so that they form a random walk; in this case, naive summation has a [[root mean square]] relative error that grows as &lt;math&gt;O\left(\varepsilon \sqrt{n}\right)&lt;/math&gt; multiplied by the condition number.&lt;ref name=Tasche&gt;Manfred Tasche and Hansmartin Zeuner, ''Handbook of Analytic-Computational Methods in Applied Mathematics'', Boca Raton, FL: CRC Press, 2000.&lt;/ref&gt;  This is still much worse than compensated summation, however. However, if the sum can be performed in twice the precision, then ''ε'' is replaced by ''ε''&lt;sup&gt;2&lt;/sup&gt;, and naive summation has a worst-case error comparable to the O(''nε''&lt;sup&gt;2&lt;/sup&gt;) term in compensated summation at the original precision.

By the same token, the Σ|''x&lt;sub&gt;i&lt;/sub&gt;''| that appears in &lt;math&gt;E_n&lt;/math&gt; above is a worst-case bound that occurs only if all the rounding errors have the same sign (and are of maximal possible magnitude).&lt;ref name=Higham93/&gt;  In practice, it is more likely that the errors have random sign, in which case terms in Σ|''x&lt;sub&gt;i&lt;/sub&gt;''| are replaced by a random walk, in which case, even for random inputs with zero mean, the error &lt;math&gt;E_n&lt;/math&gt; grows only as &lt;math&gt;O\left(\varepsilon \sqrt{n}\right)&lt;/math&gt; (ignoring the ''nε''&lt;sup&gt;2&lt;/sup&gt; term), the same rate the sum &lt;math&gt;S_n&lt;/math&gt; grows, canceling the &lt;math&gt;\sqrt{n}&lt;/math&gt; factors when the relative error is computed.  So, even for asymptotically ill-conditioned sums, the relative error for compensated summation can often be much smaller than a worst-case analysis might suggest.

==Further enhancements==
Neumaier&lt;ref name=Neumaier74&gt;{{cite journal |first=A. |last=Neumaier |doi=10.1002/zamm.19740540106 |bibcode=1974ZaMM...54...39N |title=Rundungsfehleranalyse einiger Verfahren zur Summation endlicher Summen |trans-title=Rounding Error Analysis of Some Methods for Summing Finite Sums |language=de |journal=Zeitschrift für Angewandte Mathematik und Mechanik |volume=54 |issue=1 |date=1974 |pages=39–51 |url=http://www.mat.univie.ac.at/~neum/scan/01.pdf}}&lt;/ref&gt; introduced an improved version of Kahan algorithm, which he calls an "improved Kahan–Babuška algorithm", which also covers the case when the next term to be added is larger in absolute value than the running sum, effectively swapping the role of what is large and what is small. In [[pseudocode]], the algorithm is:
 
 '''function''' NeumaierSum(input)
     '''var''' sum = 0.0
     '''var''' c = 0.0                       // A running compensation for lost low-order bits.
     '''for''' i = 1 '''to''' input.length '''do'''
         '''var''' t = sum + input[i]
         '''if''' |sum| &gt;= |input[i]| '''then'''
             c += ((sum - t) + input[i]) // If ''sum'' is bigger, low-order digits of ''input[i]'' are lost.
         '''else'''
             c += ((input[i] - t) + sum) // Else low-order digits of ''sum'' are lost.
         '''endif'''
         sum = t
     '''next''' i
     '''return''' sum + c                    // Correction only applied once in the very end.

For many sequences of numbers, both algorithms agree, but a simple example due to Peters&lt;ref name="python_fsum" /&gt; shows how they can differ. For summing &lt;math&gt;[1.0, +10^{100}, 1.0, -10^{100}]&lt;/math&gt; in double precision, Kahan's algorithm yields 0.0, whereas Neumaier's algorithm yields the correct value 2.0.

Higher-order modifications of better accuracy are also possible. For example a variant suggested by Klein&lt;ref&gt;{{Cite journal |last=A. |first=Klein |date=2006 |title=A generalized Kahan–Babuška-Summation-Algorithm |journal=Computing |volume=76 |issue=3–4 |pages=279–293 |publisher=Springer-Verlag|doi=10.1007/s00607-005-0139-x }}&lt;/ref&gt;, which he called a second-order "iterative Kahan–Babuška algorithm". In [[pseudocode]], the algorithm is:

 '''function''' KleinSum(input)
     '''var''' s = 0.0
     '''var''' cs = 0.0
     '''var''' ccs = 0.0
     '''for''' i = 1 '''to''' input.length '''do'''
         '''var''' t = s + input[i]
         '''if''' |s| &gt;= |input[i]| '''then'''
             c = (s - t) + input[i]
         '''else'''
             c = (input[i] - t) + s
         '''endif'''
         s = t
         t = cs + c
         '''if''' |cs| &gt;= |c| '''then'''
             cc = (cs - t) + c
         '''else'''
             cc = (c - t) + cs
         '''endif'''
         cs = t
         ccs = ccs + cc
     '''next''' i
     '''return''' s + cs + ccs

==Alternatives==
Although Kahan's algorithm achieves &lt;math&gt;O(1)&lt;/math&gt; error growth for summing ''n'' numbers, only slightly worse &lt;math&gt;O(\log n)&lt;/math&gt; growth can be achieved by [[pairwise summation]]: one [[recursively]] divides the set of numbers into two halves, sums each half, and then adds the two sums.&lt;ref name=Higham93/&gt;  This has the advantage of requiring the same number of arithmetic operations as the naive summation (unlike Kahan's algorithm, which requires four times the arithmetic and has a latency of four times a simple summation) and can be calculated in parallel.  The base case of the recursion could in principle be the sum of only one (or zero) numbers, but to [[amortize]] the overhead of recursion, one would normally use a larger base case.  The equivalent of pairwise summation is used in many [[fast Fourier transform]] (FFT) algorithms and is responsible for the logarithmic growth of roundoff errors in those FFTs.&lt;ref&gt;S. G. Johnson and M. Frigo, "[http://cnx.org/content/m16336/latest/ Implementing FFTs in practice], in ''[http://cnx.org/content/col10550/ Fast Fourier Transforms]'', edited by [[C. Sidney Burrus]](2008).&lt;/ref&gt; In practice, with roundoff errors of random signs, the root mean square errors of pairwise summation actually grow as &lt;math&gt;O\left(\sqrt{\log n}\right)&lt;/math&gt;.&lt;ref name=Tasche/&gt;

Another alternative is to use [[arbitrary-precision arithmetic]], which in principle need no rounding at all with a cost of much greater computational effort.  A way of performing exactly rounded sums using arbitrary precision is to extend adaptively using multiple floating-point components. This will minimize computational cost in common cases where high precision is not needed.&lt;ref&gt;Jonathan R. Shewchuk, [http://www.cs.berkeley.edu/~jrs/papers/robustr.pdf Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates], ''Discrete and Computational Geometry'', vol. 18, pp. 305–363 (October 1997).&lt;/ref&gt;&lt;ref name="python_fsum"&gt;Raymond Hettinger, [http://code.activestate.com/recipes/393090/ Recipe 393090: Binary floating point summation accurate to full precision], Python implementation of algorithm from Shewchuk (1997) article (28 March 2005).&lt;/ref&gt;  Another method that uses only integer arithmetic, but a large accumulator, was described by Kirchner and [[Ulrich W. Kulisch|Kulisch]];&lt;ref&gt;R. Kirchner, [[Ulrich W. Kulisch]], ''Accurate arithmetic for vector processors'', Journal of Parallel and Distributed Computing 5 (1988) 250–270.&lt;/ref&gt; a hardware implementation was described by Müller, Rüb and Rülling.&lt;ref&gt;M. Muller, C. Rub, W. Rulling [http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=145535&amp;isnumber=3902], ''Exact accumulation of floating-point numbers'', Proceedings [[10th IEEE Symposium on Computer Arithmetic]] (Jun 1991), {{doi|10.1109/ARITH.1991.145535}}.&lt;/ref&gt;

==Possible invalidation by compiler optimization==
In principle, a sufficiently aggressive [[Compiler optimization|optimizing compiler]] could destroy the effectiveness of Kahan summation: for example, if the compiler simplified expressions according to the [[associativity]] rules of real arithmetic, it might "simplify" the second step in the sequence
: &lt;code&gt;t = sum + y;&lt;/code&gt;
: &lt;code&gt;c = (t - sum) - y;&lt;/code&gt;
to
: &lt;code&gt;c = ((sum + y) - sum) - y;&lt;/code&gt;
and then to
: &lt;code&gt;c = 0;&lt;/code&gt;
thus eliminating the error compensation.&lt;ref name=Goldberg91&gt;{{Citation | title=What every computer scientist should know about floating-point arithmetic |first1=David | last1=Goldberg |journal=[[ACM Computing Surveys]] | volume=23 | issue=1 | pages=5–48 | date=March 1991 |doi=10.1145/103162.103163 |url=http://www.validlab.com/goldberg/paper.pdf }}.&lt;/ref&gt;  In practice, many compilers do not use associativity rules (which are only approximate in floating-point arithmetic) in simplifications, unless explicitly directed to do so by compiler options enabling "unsafe" optimizations,&lt;ref&gt;[[GNU Compiler Collection]] manual, version 4.4.3: [https://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/Optimize-Options.html 3.10 Options That Control Optimization], ''-fassociative-math'' (Jan. 21, 2010).&lt;/ref&gt;&lt;ref&gt;''[http://h21007.www2.hp.com/portal/download/files/unprot/Fortran/docs/unix-um/dfumperf.htm Compaq Fortran User Manual for Tru64 UNIX and Linux Alpha Systems] {{Webarchive|url=https://web.archive.org/web/20110607140000/http://h21007.www2.hp.com/portal/download/files/unprot/Fortran/docs/unix-um/dfumperf.htm |date=2011-06-07 }}'', section 5.9.7 Arithmetic Reordering Optimizations (retrieved March 2010).&lt;/ref&gt;&lt;ref&gt;Börje Lindh, [http://www.sun.com/blueprints/0302/optimize.pdf Application Performance Optimization], ''Sun BluePrints OnLine'' (March 2002).&lt;/ref&gt;&lt;ref&gt;Eric Fleegal, "[http://msdn.microsoft.com/en-us/library/aa289157%28VS.71%29.aspx Microsoft Visual C++ Floating-Point Optimization]", ''Microsoft Visual Studio Technical Articles''  (June 2004).&lt;/ref&gt; although the [[Intel C++ Compiler]] is one example that allows associativity-based transformations by default.&lt;ref&gt;Martyn J. Corden, "[http://software.intel.com/en-us/articles/consistency-of-floating-point-results-using-the-intel-compiler/ Consistency of floating-point results using the Intel compiler]", ''Intel technical report'' (Sep. 18, 2009).&lt;/ref&gt;  The original [[K&amp;R C]] version of the [[C programming language]] allowed the compiler to re-order floating-point expressions according to real-arithmetic associativity rules, but the subsequent [[ANSI C]] standard prohibited re-ordering in order to make C better suited for numerical applications (and more similar to [[Fortran]], which also prohibits re-ordering),&lt;ref&gt;{{cite journal |first=Tom |last=MacDonald |title=C for Numerical Computing |journal=Journal of Supercomputing |volume=5 |issue=1 |pages=31–48 |year=1991 |doi=10.1007/BF00155856}}&lt;/ref&gt; although in practice compiler options can re-enable re-ordering, as mentioned above.

==Support by libraries==
In general, built-in "sum" functions in computer languages typically provide no guarantees that a particular summation algorithm will be employed, much less Kahan summation.{{Citation needed|date=February 2010}}  The [[BLAS]] standard for [[linear algebra]] subroutines explicitly avoids mandating any particular computational order of operations for performance reasons,&lt;ref&gt;[http://www.netlib.org/blas/blast-forum/ BLAS Technical Forum], section 2.7 (August 21, 2001), [https://web.archive.org/web/20040410160918/http://www.netlib.org/blas/blast-forum/chapter2.pdf#page=17 Archived on Wayback Machine].&lt;/ref&gt; and BLAS implementations typically do not use Kahan summation.
 
The standard library of the [[Python (programming language)|Python]] computer language specifies an [https://docs.python.org/library/math.html#math.fsum fsum] function for exactly rounded summation, using the [[Jonathan Shewchuk|Shewchuk]] algorithm&lt;ref name="python_fsum"/&gt; to track multiple partial sums.

In the [[Julia (programming language)|Julia]] language, the default implementation of the &lt;code&gt;sum&lt;/code&gt; function does [[pairwise summation]] for high accuracy with good performance,&lt;ref&gt;[https://github.com/JuliaLang/julia/pull/4039 RFC: use pairwise summation for sum, cumsum, and cumprod], github.com/JuliaLang/julia pull request #4039 (August 2013).&lt;/ref&gt; but an external library provides an implementation of Neumaier's variant named &lt;code&gt;sum_kbn&lt;/code&gt; for the cases when higher accuracy is needed.&lt;ref&gt;[https://github.com/JuliaMath/KahanSummation.jl KahanSummation library] in Julia.&lt;/ref&gt;

In the [[C Sharp (programming language)|C#]] language, [https://www.nuget.org/packages/HPCsharp HPCsharp nuget package] implements the Neumaier variant and [[pairwise summation]]: both as scalar, data-parallel using [[SIMD]] processor instructions, and parallel multi-core.&lt;ref&gt;[https://github.com/DragonSpit/HPCsharp HPCsharp nuget package of high performance algorithms].&lt;/ref&gt;

==See also==
* [[Algorithms for calculating variance]], which includes stable summation

==References==
{{reflist|30em}}

==External links==
* [http://www.ddj.com/cpp/184403224 Floating-point Summation, Dr. Dobb's Journal September, 1996]

{{DEFAULTSORT:Kahan Summation Algorithm}}
[[Category:Computer arithmetic]]
[[Category:Numerical analysis]]
[[Category:Articles with example pseudocode]]</text>
      <sha1>k6ntmzimovya5vs8sgujvi9k6tjw6q7</sha1>
    </revision>
  </page>
</mediawiki>
