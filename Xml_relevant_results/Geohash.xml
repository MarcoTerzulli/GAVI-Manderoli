<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>Wikipedia</sitename>
    <dbname>enwiki</dbname>
    <base>https://en.wikipedia.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.35.0-wmf.31</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">Wikipedia</namespace>
      <namespace key="5" case="first-letter">Wikipedia talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="100" case="first-letter">Portal</namespace>
      <namespace key="101" case="first-letter">Portal talk</namespace>
      <namespace key="108" case="first-letter">Book</namespace>
      <namespace key="109" case="first-letter">Book talk</namespace>
      <namespace key="118" case="first-letter">Draft</namespace>
      <namespace key="119" case="first-letter">Draft talk</namespace>
      <namespace key="446" case="first-letter">Education Program</namespace>
      <namespace key="447" case="first-letter">Education Program talk</namespace>
      <namespace key="710" case="first-letter">TimedText</namespace>
      <namespace key="711" case="first-letter">TimedText talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Geohash</title>
    <ns>0</ns>
    <id>15974212</id>
    <revision>
      <id>955019405</id>
      <parentid>952630651</parentid>
      <timestamp>2020-05-05T14:38:16Z</timestamp>
      <contributor>
        <username>Anguspearson</username>
        <id>11404964</id>
      </contributor>
      <minor/>
      <comment>Clarify prefix length relation to spatial distance</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="22590" xml:space="preserve">{{about|the system for encoding geographic coordinates|the game|Geohashing}}
{{short description|A similarity-hashing function invented in 2008, specific for geographic coordinates compressing  or for location clustering}}

'''Geohash''' is a [[public domain]] [[geocode#Geocode system|geocode system]]  invented in 2008 by Gustavo Niemeyer&lt;ref name="first2008"&gt;Evidences at the [[Wayback Machine]] (also with  [https://web.archive.org/web/20080305090620/http://en.wikipedia.org/wiki/Geohash 2008's records of this article]):
* [https://web.archive.org/web/20080305223755/http://blog.labix.org/#post-85 labix.org in 2008, the G. Niemeyer's blog announcing Geohash];
*  [https://web.archive.org/web/20120112004608/http://www.bigfastblog.com/geohash-intro an article about Geohash witnessing and citing G. Niemeyer works, before 2012];
* [https://web.archive.org/web/20180309054335/https://forums.geocaching.com/GC/index.php?%2Ftopic%2F186412-geohashorg%2F G. Niemeyer's post at forums.geocaching.com announcing Geohash in Feb. 2008].&lt;/ref&gt; and (similar work in 1966) G.M. Morton,&lt;ref name="morton66"&gt;
G. M. Morton (1966)[https://domino.research.ibm.com/library/cyberdig.nsf/papers/0DABF9473B9C86D48525779800566A39/$File/Morton1966.pdf ''"A Computer Oriented Geodetic Data Base and a New Technique in File Sequencing"'']. Report in IBM Canada.&lt;/ref&gt; which encodes a geographic location into a short string of letters and digits. It is a hierarchical spatial data structure which subdivides space into buckets of [[Grid (spatial index)|grid]] shape, which is one of the many applications of what is known as a [[Z-order curve]], and generally [[space-filling curves]].

Geohashes offer properties like arbitrary precision and the possibility of gradually removing characters from the end of the code to reduce its size (and gradually lose precision). Geohashing guarantees that the longer a shared prefix between two geohashes is, the spatially closer they are together. The reverse of this is not guaranteed, as two points can be very close but have a short or no shared prefix.

== History ==

The core part of the Geohash algorithm and the first initiative to similar solution was documented in a report of G.M. Morton in 1966, "A Computer Oriented Geodetic Data Base and a New Technique in File Sequencing".&lt;ref name="morton66"/&gt; The Morton work was used for efficient implementations of [[Z-order curve]], like in [https://github.com/yinqiwen/geohash-int this modern (2014) Geohash-integer version], based on direct interleave [[64-bit computing|64-bits integers]]. But his [[geocode]] proposal was not [[human-readable]] and was not popular.

Apparently, in the late 2000s, G. Niemeyer still didn't know about Morton's work, and reinvented it, adding the use of [[base32]] representation.  In February 2008, together with the announcement of the system,&lt;ref name="first2008"/&gt; he launched the website &lt;code&gt;http://geohash.org&lt;/code&gt;, which allows users to convert geographic coordinates to short [[Uniform Resource Locator|URL]]s which uniquely identify positions on the [[Earth]], so that referencing them in [[email]]s, [[Internet forum|forums]], and [[website]]s is more convenient.

Many variations has been developed, as the [[OpenStreetMap]]'s  ''short link''&lt;ref name="osm_short_link"&gt;
The [[OpenStreetMap]]'s ''short link'', [https://wiki.openstreetmap.org/wiki/Shortlink documented in wiki.openstreetmap.org], was released   [https://github.com/openstreetmap/openstreetmap-website/blob/1d8e66016c4cdf465d06198cfbbfe76613ed3bfc/lib/short_link.rb in 2009], is near the same source-code  [https://github.com/openstreetmap/openstreetmap-website/blob/master/lib/short_link.rb 10 years after]. It is strongly based on [[Z-order curve|Morton's interlace algorithm]].
&lt;/ref&gt; (using [[base64]] instead of base32) in 2009,  the ''64-bit Geohash''&lt;ref&gt;
The "Geohash binary 64 bits" have  classic solutions, as [https://github.com/yinqiwen/geohash-int yinqiwen/geohash-int], and optimized solutions, as [https://mmcloughlin.com/posts/geohash-assembly mmcloughlin/geohash-assembly].
&lt;/ref&gt; in 2014, the exotic ''Hilbert-Geohash''&lt;ref&gt;Tibor Vukovic (2016), "Hilbert-Geohash - Hashing Geographical Point Data Using the Hilbert Space-Filling Curve"''. https://pdfs.semanticscholar.org/d23c/996f44b1443fca76276ce8d37239fb8fd6f9.pdf&lt;/ref&gt;&lt;ref&gt;https://github.com/tammoippen/geohash-hilbert&lt;/ref&gt; in 2016, and others.

== Typical and main usages ==
To obtain the Geohash, the user provides an address to be [[geocode]]d, or [[latitude and longitude]] coordinates, in a single input box (most commonly used formats for latitude and longitude pairs are accepted), and performs the request.

Besides showing the latitude and longitude corresponding to the given Geohash, users who navigate to a Geohash at geohash.org are also presented with an embedded map, and may download a [[GPX (data transfer)|GPX]] file, or transfer the waypoint directly to certain [[GPS]] receivers.  Links are also provided to external sites that may provide further details around the specified
location.

For example, the coordinate pair &lt;code&gt;57.64911,10.40744&lt;/code&gt; (near the tip of the [[peninsula]] of [[Jutland, Denmark]]) produces a slightly shorter hash of &lt;code&gt;u4pruydqqvj&lt;/code&gt;.

The main usages of Geohashes are:

* As a unique identifier.
* To represent point data, e.g. in databases.

Geohashes have also been proposed to be used for [[geotagging]].

When used in a database, the structure of geohashed data has two advantages. First, data indexed by geohash will have all points for a given rectangular area in contiguous slices (the number of slices depends on the precision required and the presence of geohash "fault lines"). This is especially useful in database systems where queries on a single index are much easier or faster than multiple-index queries. Second, this index structure can be used for a quick-and-dirty proximity search: the closest points are often among the closest geohashes.

== Technical description ==
A formal description for Computational and Mathematical views.

=== Textual representation ===
For exact latitude and longitude translations Geohash is a ''spatial index'' of [[base 4]], because it transforms the continuous latitude and lontitude space coordinates into a hierarchical discrete grid, using  a recurrent four-partition of the space. To be a compact code it uses [[base 32]] and represents its values by the following alphabet, that is the "standard textual representation".

{| class="wikitable" style="text-align:center"
|-
! Decimal
| 0 || 1 || 2 || 3 || 4 || 5 || 6 || 7 || 8 || 9 || 10 || 11 || 12 || 13 || 14 || 15
|-
! Base 32
| 0 || 1 || 2 || 3 || 4 || 5 || 6 || 7 || 8 || 9 ||  b ||  c ||  d ||  e ||  f ||  g
|-
| style="font: 0.5em/0.5em serif;" colspan="20" | &amp;nbsp;
|-
! Decimal
| 16 || 17 || 18 || 19 || 20 || 21 || 22 || 23 || 24 || 25 || 26 || 27 || 28 || 29 || 30 || 31
|-
! Base 32
|  h ||  j ||  k ||  m ||  n ||  p ||  q ||  r ||  s ||  t ||  u ||  v ||  w ||  x ||  y ||  z
|}

The "Geohash alphabet" (32ghs) uses all digits 0-9 and almost all lower case letters except "a", "i", "l" and "o".

For example,  using the table above and the constant &lt;math&gt;B=32&lt;/math&gt;, the Geohash &lt;code&gt;ezs42&lt;/code&gt; can be converted to a decimal representation by ordinary [[Positional notation#Base of the numeral system|positional notation]]:

: [&lt;code&gt;ezs42&lt;/code&gt;]&lt;sub&gt;32ghs&lt;/sub&gt; = &lt;math&gt;[(e \times B^4) + (z \times B^3) + (s \times B^2) + (4 \times B^1) + (2 \times B^0)]_{32ghs}&lt;/math&gt;

: = &lt;math&gt;[e]_{32ghs} \times B^4 + [z]_{32ghs} \times B^3 + [s]_{32ghs} \times B^2 + [4]_{32ghs} \times B^1 + [2]_{32ghs} \times B^0&lt;/math&gt;

: = &lt;math&gt;[13]_{10} \times B^4 + [31]_{10} \times B^3 + [24]_{10} \times B^2 + [4]_{10} \times B^1 + [2]_{10} \times B^0&lt;/math&gt;

: = &lt;math&gt;13  \times 1048576 + 31 \times 32768 + 24 \times 1024 + 4 \times 32 + 2 \times 1&lt;/math&gt; = &lt;math&gt;13631488 + 1015808 + 24576 + 128 + 2 = 14672002&lt;/math&gt;

=== Geometrical representation ===
The geometry of the Geohash have a mixed spatial representation:

* Geohashes with 2, 4, 6, ... ''e'' digits ([[Parity (mathematics)|even]] digits) are represented by [[Z-order curve]] in a "regular grid" where decoded pair (latitude,longitude) has uniform uncertainty, valid as [[Geo URI scheme#Uncertainty|Geo URI]].
* Geohashes with 1, 3, 5, ... ''d'' digits (odd digits) are represented by  "И-order curve". Latitude and longitude of the decoded pair has different uncertainty (longitude is truncated).

[[File:Geohash-OddEvenDigits.png.png|680px|center]]

[[File:MortonCurve64grid-mergingCells.png|thumb|Merging cells of the "next level" to obtain a geometrical representation of the "odd-digit Geohash".]]

Is possible to build the  "И-order curve" from Z-order by merging neighboring cells and indexing the result rectangular grid by the function ''j''=[[Floor and ceiling functions|floor]](''i'' ÷ 2). The side illustration shows how to obtain  the grid of 32 rectangular cells from the grid of 64 square cells.

The most important property of Geohash for humans is that it '''preservers ''spatial hierarchy'' in the ''code prefixes'''''. &lt;br/&gt;For example, in the "1 Geohash digit grid" illustration  of 32 rectangles, above, the spatial region of the code &lt;code&gt;e&lt;/code&gt; (rectangle of greyish blue circle at position 4,3) is preserved with prefix &lt;code&gt;e&lt;/code&gt; in the "2 digit grid" of 1024 rectangles (scale showing &lt;code&gt;em&lt;/code&gt; and greyish green to blue circles at grid).

=== Algorithm and example ===

Using the hash &lt;code&gt;ezs42&lt;/code&gt; as an example, here is how it is decoded into a decimal latitude and longitude. The first step is decoding it from textual "[[#Textual representation|base 32]]ghs", as showed above, to obtain the binary representation:

: &lt;math&gt;[e]_{32ghs}=[13]_{10}=[01101]_2&lt;/math&gt;
: &lt;math&gt;[z]_{32ghs}=[31]_{10}=[11111]_2&lt;/math&gt;
: &lt;math&gt;[s]_{32ghs}=[24]_{10}=[11000]_2&lt;/math&gt;
: &lt;math&gt;[4]_{32ghs}=[4]_{10}=[00100]_2&lt;/math&gt;
: &lt;math&gt;[2]_{32ghs}=[2]_{10}=[00010]_2&lt;/math&gt;.

This operation results in the [[bit]]s &lt;code&gt;01101&lt;/code&gt; &lt;code&gt;11111&lt;/code&gt; &lt;code&gt;11000&lt;/code&gt; &lt;code&gt;00100&lt;/code&gt; &lt;code&gt;00010&lt;/code&gt;.  Assuming that counting starts at 0 in the left side, the even bits are taken for the longitude code (&lt;code&gt;0111110000000&lt;/code&gt;), while the odd bits are taken for the latitude code (&lt;code&gt;101111001001&lt;/code&gt;).

Each binary code is then used in a series of divisions, considering one bit at a time, again from the left to the right side.  For the latitude value, the interval -90 to +90 is divided by 2, producing two intervals: -90 to 0, and 0 to +90.  Since the first bit is 1, the higher interval is chosen, and becomes the current interval. The procedure is repeated for all bits in the code.  Finally, the latitude value is the center of the resulting interval.  Longitudes are processed in an equivalent way, keeping in mind that the initial interval is -180 to +180.

For example, in the latitude code &lt;code&gt;101111001001&lt;/code&gt;, the first bit is 1, so we know our latitude is somewhere between 0 and 90. Without any more bits, we'd guess the latitude was 45, giving us an error of ±45. Since more bits are available, we can continue with the next bit, and each subsequent bit halves this error. This table shows the effect of each bit. At each stage, the relevant half of the range is highlighted in green; a low bit selects the lower range, a high bit selects the upper range.

The column “mean value” shows the latitude, simply the mean value of the range. Each subsequent bit makes this value more precise.

{| class="wikitable" style="text-align:right"
! colspan="7" |Latitude code 101111001001
|- style="text-align:center"
! bit position
! bit value
! min
! mid
! max
! mean value
! maximum error
|-
| 0 || 1 || -90.000 || style="background:#cceecc" |0.000 || style="background:#cceecc" |90.000 || 45.000 || 45.000
|-
| 1 || 0 || style="background:#cceecc" |0.000 || style="background:#cceecc" |45.000 || 90.000 || 22.500 || 22.500
|-
| 2 || 1 || 0.000 || style="background:#cceecc" |22.500 || style="background:#cceecc" |45.000 || 33.750 || 11.250
|-
| 3 || 1 || 22.500 || style="background:#cceecc" |33.750 || style="background:#cceecc" |45.000 || 39.375 || 5.625
|-
| 4 || 1 || 33.750 || style="background:#cceecc" |39.375 || style="background:#cceecc" |45.000 || 42.188 || 2.813
|-
| 5 || 1 || 39.375 || style="background:#cceecc" |42.188 || style="background:#cceecc" |45.000 || 43.594 || 1.406
|-
| 6 || 0 || style="background:#cceecc" |42.188 || style="background:#cceecc" |43.594 || 45.000 || 42.891 || 0.703
|-
| 7 || 0 || style="background:#cceecc" |42.188 || style="background:#cceecc" |42.891 || 43.594 || 42.539 || 0.352
|-
| 8 || 1 || 42.188 || style="background:#cceecc" |42.539 || style="background:#cceecc" |42.891 || 42.715 || 0.176
|-
| 9 || 0 || style="background:#cceecc" |42.539 || style="background:#cceecc" |42.715 || 42.891 || 42.627 || 0.088
|-
| 10 || 0 || style="background:#cceecc" |42.539 || style="background:#cceecc" |42.627 || 42.715 || 42.583 || 0.044
|-
| 11 || 1 || 42.539 || style="background:#cceecc" |42.583 || style="background:#cceecc" |42.627 || 42.605 || 0.022
|}

{| class="wikitable" style="text-align:right"
! colspan="7" |Longitude code 0111110000000
|- style="text-align:center"
! bit position
! bit value
! min
! mid
! max
! mean value
! maximum error
|-
| 0 || 0 || style="background:#cceecc"| -180.000 || style="background:#cceecc" |0.000 || 180.000 || -90.000 || 90.000
|-
| 1 || 1 || -180.000 || style="background:#cceecc" |-90.000 || style="background:#cceecc" |0.000 || -45.000 || 45.000
|-
| 2 || 1 || -90.000 || style="background:#cceecc" |-45.000 || style="background:#cceecc" |0.000 || -22.500 || 22.500
|-
| 3 || 1 || -45.000 || style="background:#cceecc" |-22.500 || style="background:#cceecc" |0.000 || -11.250 || 11.250
|-
| 4 || 1 || -22.500 || style="background:#cceecc" |-11.250 || style="background:#cceecc" |0.000 ||  -5.625 || 5.625
|-
| 5 || 1 || -11.250 || style="background:#cceecc" |-5.625 || style="background:#cceecc" |0.000 ||  -2.813 || 2.813
|-
| 6 || 0 || style="background:#cceecc" | -5.625 || style="background:#cceecc" | -2.813 || 0.000 ||-4.219
| 1.406
|-
| 7 || 0 || style="background:#cceecc" | -5.625 || style="background:#cceecc" |-4.219
| -2.813 ||-4.922
| 0.703
|-
| 8 || 0 || style="background:#cceecc" | -5.625 || style="background:#cceecc" |-4.922
|&lt;nowiki&gt;-4.219&lt;/nowiki&gt;
|&lt;nowiki&gt;-5.273&lt;/nowiki&gt;
| 0.352
|-
| 9 || 0 || style="background:#cceecc" | -5.625 || style="background:#cceecc" |-5.273
|&lt;nowiki&gt;-4.922&lt;/nowiki&gt;
|&lt;nowiki&gt;-5.449&lt;/nowiki&gt;
| 0.176
|-
| 10 || 0 || style="background:#cceecc" | -5.625 || style="background:#cceecc" |-5.449
|&lt;nowiki&gt;-5.273&lt;/nowiki&gt;
|&lt;nowiki&gt;-5.537&lt;/nowiki&gt;
| 0.088
|-
| 11 || 0 || style="background:#cceecc" | -5.625 || style="background:#cceecc" |-5.537
|&lt;nowiki&gt;-5.449&lt;/nowiki&gt;
|&lt;nowiki&gt;-5.581&lt;/nowiki&gt;
|0.044
|-
|12 || 0 || style="background:#cceecc" | -5.625 || style="background:#cceecc" |-5.581
|&lt;nowiki&gt;-5.537&lt;/nowiki&gt;
| -5.603
|0.022
|}

(The numbers in the above table have been rounded to 3 decimal places for clarity)

Final rounding should be done carefully in a way that

:&lt;math&gt; \min \le \mathrm{round}(value) \le \max &lt;/math&gt;

So while rounding 42.605 to 42.61 or 42.6 is correct, rounding to 43 is not.

=== Digits and precision in km ===

{| class="wikitable"
|-
! geohash length
! lat bits
! lng bits
! lat error
! lng error
! km error
|-
| 1 || 2 || 3 || ±23 || ±23 || &amp;#8199;±2500
|-
| 2 || 5 || 5 || &amp;#8199;±2.8 || &amp;#8199;±5.6 || &amp;#8199;±630
|-
| 3 || 7 || 8 || &amp;#8199;±0.70 || &amp;#8199;±0.70 || &amp;#8199;&amp;#8199;±78
|-
| 4 || 10 || 10 || &amp;#8199;±0.087 || &amp;#8199;±0.18 || &amp;#8199;&amp;#8199;±20
|-
| 5 || 12 || 13 || &amp;#8199;±0.022 || &amp;#8199;±0.022 || &amp;#8199;&amp;#8199;&amp;#8199;±2.4
|-
| 6 || 15 || 15 || &amp;#8199;±0.0027 || &amp;#8199;±0.0055 || &amp;#8199;&amp;#8199;&amp;#8199;±0.61
|-
| 7 || 17 || 18 || &amp;#8199;±0.00068 || &amp;#8199;±0.00068 || &amp;#8199;&amp;#8199;&amp;#8199;±0.076
|-
| 8 || 20 || 20 || &amp;#8199;±0.000085 || &amp;#8199;±0.00017 || &amp;#8199;&amp;#8199;&amp;#8199;±0.019
|}

== Limitations when used for deciding proximity ==
=== Edge cases ===
Geohashes can be used to find points in proximity to each other based on a common prefix. However, [[edge case]] locations close to each other but on opposite sides of the 180 degree meridian will result in Geohash codes with no common prefix (different longitudes for near physical locations). Points close to the North and South poles will have very different geohashes (different longitudes for near physical locations).

Two close locations on either side of the Equator (or Greenwich meridian) will not have a long common prefix since they belong to different 'halves' of the world. Put simply, one location's binary latitude (or longitude) will be 011111... and the other 100000...., so they will not have a common prefix and most bits will be flipped. This can also be seen as a consequence of relying on the [[Z-order curve]] (which could more appropriately be called an N-order visit in this case) for ordering the points, as two points close by might be visited at very different times. However, two points with a long common prefix will be close by.

In order to do a proximity search, one could compute the southwest corner (low geohash with low latitude and longitude) and northeast corner (high geohash with high latitude and longitude) of a bounding box and search for geohashes between those two. This search will retrieve all points in the z-order curve between the two corners, which can be far too many points. This method also breaks down at the 180 meridians and the poles. Solr uses a filter list of prefixes, by computing the prefixes of the nearest squares close to the geohash [https://web.archive.org/web/20140513235817/http://lucenerevolution.org/sites/default/files/Lucene%20Rev%20Preso%20Smiley%20Spatial%20Search.pdf].

=== Non-linearity ===
Since a geohash (in this implementation) is based on [[Geographical coordinate system|coordinates of longitude and latitude]] the distance between two geohashes reflects the distance in latitude/longitude coordinates between two points, which does not translate to actual distance, see [[Haversine formula]].

Example of non-linearity for latitude-longitude system:
* At the Equator (0 Degrees) the length of a degree of longitude is 111.320&amp;nbsp;km, while a degree of latitude measures 110.574&amp;nbsp;km, an error of 0.67%.
* At 30 Degrees (Mid Latitudes) the error is 110.852/96.486 = 14.89%
* At 60 Degrees (High Arctic) the error is 111.412/55.800 = 99.67%, reaching infinity at the poles.

Note that these limitations are not due to geohashing, and not due to latitude-longitude coordinates, but due to the difficulty of mapping coordinates on a sphere (non linear and with wrapping of values, similar to modulo arithmetic) to two dimensional coordinates and the difficulty of exploring a two dimensional space uniformly. The first is related to [[Geographical coordinate system]] and [[Map projection]], and the other to [[Hilbert curve]] and [[z-order curve]]. Once a coordinate system is found that represents points linearly in distance and wraps up at the edges, and can be explored uniformly, applying geohashing to those coordinates will not suffer from the limitations above.

While it is possible to apply geohashing to an area with a [[Cartesian coordinate system]], it would then only apply to the area where the coordinate system applies.

Despite those issues, there are possible workarounds, and the algorithm has been successfully used in Elasticsearch,&lt;ref&gt;[https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-shape.html geo_shape Datatype in Elasticsearch]&lt;/ref&gt; MongoDB,&lt;ref&gt;[http://www.mongodb.org/display/DOCS/Geospatial+Indexing Geospatial Indexing in MongoDB]&lt;/ref&gt; HBase, Redis,&lt;ref&gt;[https://redis.io/commands/geoadd]&lt;/ref&gt; and [[Accumulo]]&lt;ref&gt;[https://geomesa.github.io/assets/outreach/SpatioTemporalIndexing_IEEEcopyright.pdf Spatio-temporal Indexing in Non-relational Distributed Databases]&lt;/ref&gt; to implement proximity searches.

== Similar indexing systems ==
An alternative to storing Geohashes as strings in a database are [http://www.cs.umd.edu/~hjs/pubs/SametVisualComputer89.pdf Locational codes], which are also called spatial keys and similar to QuadTiles.&lt;ref&gt;[http://karussell.wordpress.com/2012/05/23/spatial-keys-memory-efficient-geohashes/ Spatial Keys]&lt;/ref&gt;&lt;ref&gt;[https://wiki.openstreetmap.org/wiki/QuadTiles QuadTiles]&lt;/ref&gt;

In some  [[geographical information systems]] and [[Big Data]] spatial databases, a [[Hilbert curve]] based indexation can be used as an alternative to [[Z-order curve]], like in the ''S2 Geometry library''.&lt;ref&gt;"S2 Geometry Library" for optimized spatial indexation, https://s2geometry.io&lt;/ref&gt;

== Licensing ==

The Geohash algorithm was put in the [[public domain]] by its inventor in a public announcement on February 26, 2008.&lt;ref&gt;[http://forums.groundspeak.com/GC/index.php?showtopic=186412 geohash.org announcement post in groundspeak.com forum]&lt;/ref&gt;

While comparable algorithms have been successfully patented&lt;ref&gt;[http://www.freepatentsonline.com/20050023524.html Compact text encoding of latitude/longitude coordinates - Patent 20050023524]&lt;/ref&gt; and
had copyright claimed upon,&lt;ref&gt;[http://www.gps-practice-and-fun.com/nacgeo.html#Microsoft Does Microsoft Infringe the Natural Area Coding System?] {{webarchive|url=https://web.archive.org/web/20101228091709/http://www.gps-practice-and-fun.com/nacgeo.html |date=2010-12-28 }}&lt;/ref&gt;&lt;ref&gt;[http://www.nacgeo.com/nacsite/licensing/ The Natural Area Coding System - Legal and Licensing]&lt;/ref&gt; GeoHash is based on an entirely different algorithm and approach.

== See also ==
* [[List of geodesic-geocoding systems]]
* [[Geohash-36]] (is not a Geohash-variant)
* [[Grid (spatial index)]]
* [[Maidenhead Locator System]]
* [[Military Grid Reference System]]
* [[Morton number (number theory)]]
* [[Natural Area Code]]
* [[Numbering scheme]]
* [[Open Location Code]] (plus code)
* [[space-filling curves]]
* [[what3words]]
* [[Z-order curve]]

== References ==

{{reflist|30em}}

== External links ==

* {{official website|http://geohash.org/}}
* [http://www.elasticsearch.org/guide/en/elasticsearch/guide/current/geoloc.html elasticsearch: the definitive guide - Geo]
* [https://github.com/adrianulbona/jts-discretizer Geohash approximations for JTS geometries]
* [https://geohash.measurement.earth/ The Geohash Playground]
{{geocoding-systems}}

[[Category:Geographic coordinate systems]]
[[Category:Geocodes]]
[[Category:2008 introductions]]</text>
      <sha1>7ozxqwv0cxhooi57cfaljgtdjfjx34o</sha1>
    </revision>
  </page>
</mediawiki>
